<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Location, Location, Location</title>
    <style>
        :root {
            --color-primary: #1a73e8;
            --color-text: #1f2a37;
            --color-text-muted: #6b7280;
            --color-border: #d1d7e0;
            --color-bg: #f5f6f8;
            --color-card: #ffffff;
            font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
        }

        body {
            margin: 0;
            background: var(--color-bg);
            color: var(--color-text);
        }

        main {
            max-width: 720px;
            margin: 0 auto;
            padding: 20px 16px 40px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        h1 {
            font-size: 1.6rem;
            margin: 0;
            text-align: center;
        }

        p {
            margin: 0;
            line-height: 1.4;
        }

        .card {
            background: var(--color-card);
            border-radius: 14px;
            padding: 16px;
            box-shadow: 0 6px 18px rgba(18, 24, 40, 0.08);
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        label {
            font-weight: 600;
        }

        input[type="text"] {
            flex: 1;
            padding: 12px 14px;
            padding-right: 36px;
            border-radius: 10px;
            border: 1px solid var(--color-border);
            font-size: 1rem;
            background: var(--color-card);
            color: inherit;
        }

        .input-wrapper {
            position: relative;
            flex: 1;
            display: flex;
        }

        #clear-button {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--color-text-muted);
            font-size: 1.3rem;
            cursor: pointer;
            padding: 4px 8px;
            line-height: 1;
        }

        #clear-button:hover {
            color: var(--color-text);
        }

        button {
            padding: 12px 16px;
            border-radius: 10px;
            border: none;
            background: var(--color-primary);
            color: #ffffff;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .row {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .map-frame {
            width: 100%;
            min-height: 260px;
            border: none;
            border-radius: 12px;
            background: #e2e8f0;
        }

        .link-box a {
            color: var(--color-primary);
            word-break: break-all;
        }

        .status {
            font-size: 0.9rem;
            color: var(--color-text-muted);
        }

        .status-right {
            text-align: right;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.95rem;
            table-layout: fixed;
        }

        th,
        td {
            text-align: center;
            padding: 8px 0;
            border-bottom: 1px solid #e5e7eb;
        }

        th {
            font-weight: 600;
            color: #4b5563;
        }

        th:first-child {
            width: 40%;
        }

        th:nth-child(2),
        th:nth-child(3),
        th:nth-child(4) {
            width: 20%;
        }

        .table-wrapper {
            overflow: visible;
        }

        .time-link {
            color: var(--color-primary);
            text-decoration: none;
            font-weight: 600;
        }

        .time-link[aria-disabled="true"] {
            color: #9ca3af;
            pointer-events: none;
        }

        .time-link.time-green {
            color: #16a34a;
        }

        .time-link.time-orange {
            color: #d97706;
        }

        .time-link.time-red {
            color: #dc2626;
        }

        .text-left {
            text-align: left;
            padding-left: 8px;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        .info-tooltip {
            position: relative;
            display: inline-block;
            margin-left: 4px;
            cursor: help;
            color: var(--color-text-muted);
            font-size: 0.85em;
        }

        .info-tooltip .tooltip-text {
            visibility: hidden;
            opacity: 0;
            position: absolute;
            bottom: 125%;
            right: 0;
            background: var(--color-text);
            color: var(--color-card);
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 0.85rem;
            white-space: nowrap;
            z-index: 10;
            transition: opacity 0.2s;
        }

        .info-tooltip .tooltip-text::after {
            content: "";
            position: absolute;
            top: 100%;
            right: 8px;
            border: 5px solid transparent;
            border-top-color: var(--color-text);
        }

        .info-tooltip:hover .tooltip-text,
        .info-tooltip.active .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        .rating-good {
            color: #16a34a;
            font-weight: 600;
        }

        .rating-moderate {
            color: #d97706;
            font-weight: 600;
        }

        .rating-bad {
            color: #dc2626;
            font-weight: 600;
        }

        @media (min-width: 600px) {
            .row {
                flex-direction: row;
                align-items: flex-end;
            }

            .row button {
                flex: 0 0 150px;
            }
        }
    </style>
</head>

<body>
    <main>
        <header class="card">
            <h1>Location, Location, Location</h1>
        </header>

        <section class="card">
            <h2>Address</h2>
            <div class="row">
                <div class="input-wrapper">
                    <input id="address" type="text" placeholder="e.g. Freilagerstrasse 99, 8047 ZÃ¼rich" />
                    <button id="clear-button" type="button" aria-label="Clear input">&times;</button>
                </div>
                <button id="search-button" aria-label="Search for address">Search</button>
            </div>
            <p class="status" id="search-status">Enter an address to begin.</p>
        </section>

        <section class="card">
            <h2>Map</h2>
            <iframe id="map-frame" class="map-frame" title="Google map" loading="lazy"></iframe>
            <div class="link-box">
                <strong>Additional maps:</strong>
                <ul>
                    <li><a id="shade-link" href="https://shademap.app/" target="_blank" rel="noopener">ShadeMap</a></li>
                    <li><a id="schweiz-link"
                            href="https://schweizmobil.ch/de/map?season=summer&bgLayer=pk&layers=&detours=no&photos=no&logos=no&shooting=yes&resolution=4.60&E=2679220&N=1247867"
                            target="_blank" rel="noopener">SchweizMobil</a></li>
                </ul>
            </div>
        </section>

        <section class="card">
            <h2>Travel times</h2>
            <div class="table-wrapper">
                <table>
                    <thead>
                        <tr>
                            <th class="text-left">Destination</th>
                            <th>ðŸš²</th>
                            <th>ðŸšŒ</th>
                            <th>ðŸš—</th>
                        </tr>
                    </thead>
                    <tbody id="travel-times-body"></tbody>
                </table>
            </div>
            <p class="status status-right">Estimates only &#8594; Click the links for live data</p>
        </section>

        <section class="card">
            <h2>Miscellaneous</h2>
            <div class="table-wrapper">
                <table>
                    <tbody id="nearby-body"></tbody>
                </table>
            </div>
        </section>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
    <script>
        const addressInput = document.getElementById("address");
        const searchButton = document.getElementById("search-button");
        const searchStatus = document.getElementById("search-status");
        const mapFrame = document.getElementById("map-frame");
        const shadeLink = document.getElementById("shade-link");
        const schweizLink = document.getElementById("schweiz-link");
        const travelTimesBody = document.getElementById("travel-times-body");

        const destinations = [
            {
                id: "zh",
                name: "ZÃ¼rich HB",
                address: "Zurich HB, Bahnhofplatz, 8001 ZÃ¼rich",
                lat: 47.378177,
                lng: 8.540192,
            },
            {
                id: "usz",
                name: "USZ",
                address: "University Hospital of ZÃ¼rich, RÃ¤mistrasse 100, 8091 ZÃ¼rich",
                lat: 47.3766194,
                lng: 8.5465972,
            },
            {
                id: "sensirion",
                name: "Sensirion",
                address: "Sensirion AG, LaubisrÃ¼tistrasse 50, 8712 StÃ¤fa",
                lat: 47.2379872,
                lng: 8.7447918,
            }
        ];

        // Municipal tax multipliers for Canton Zurich (2026)
        // Source: https://opendata.swiss/de/dataset/steuerfusse-der-zurcher-gemeinden-fur-naturliche-und-juristische-personen
        const taxMultipliers = {
            "Aeugst a.A.": 92, "Affoltern a.A.": 122, "Bonstetten": 106, "Hausen a.A.": 112,
            "Hedingen": 100, "Kappel a.A.": 102, "Knonau": 116, "Maschwanden": 128,
            "Mettmenstetten": 98, "Obfelden": 118, "Ottenbach": 115, "Rifferswil": 120,
            "Stallikon": 101, "Wettswil a.A.": 89, "Benken": 110, "Berg a.I.": 98,
            "Buch a.I.": 106, "Dachsen": 111, "Dorf": 99, "Feuerthalen": 114,
            "Flaach": 107, "Flurlingen": 111, "Henggart": 111, "Kleinandelfingen": 118,
            "Laufen-Uhwiesen": 104, "Marthalen": 107, "Ossingen": 113, "Rheinau": 112,
            "Thalheim a.d.Th.": 117, "TrÃ¼llikon": 110, "Truttikon": 107, "Volken": 111,
            "BachenbÃ¼lach": 106, "Bassersdorf": 114, "BÃ¼lach": 114, "Eglisau": 113,
            "Embrach": 112, "Freienstein-Teufen": 99, "Glattfelden": 120, "HÃ¶ri": 110,
            "HÃ¼ntwangen": 108, "Kloten": 100, "Lufingen": 97, "NÃ¼rensdorf": 90,
            "Oberembrach": 117, "Opfikon": 94, "Rafz": 113, "Rorbas": 103,
            "Wasterkingen": 116, "Wil": 97, "Winkel": 76, "Bachs": 128,
            "Boppelsen": 94, "Buchs": 105, "DÃ¤llikon": 107, "DÃ¤nikon": 120,
            "Dielsdorf": 105, "Neerach": 77, "Niederglatt": 106, "Niederhasli": 112,
            "Niederweningen": 100, "Oberglatt": 119, "Oberweningen": 94, "Otelfingen": 108,
            "Regensberg": 115, "Regensdorf": 117, "RÃ¼mlang": 113, "Schleinikon": 106,
            "SchÃ¶fflisdorf": 94, "Stadel": 111, "Steinmaur": 108, "Weiach": 96,
            "BÃ¤retswil": 104, "Bubikon": 118, "DÃ¼rnten": 113, "Fischenthal": 122,
            "Gossau": 117, "GrÃ¼ningen": 116, "Hinwil": 116, "RÃ¼ti": 119,
            "Wald": 122, "Wetzikon": 119, "Adliswil": 104, "Kilchberg": 72,
            "Langnau a.A.": 106, "Oberrieden": 84, "Richterswil": 99, "RÃ¼schlikon": 75,
            "Thalwil": 78, "Erlenbach": 76, "Herrliberg": 73, "Hombrechtikon": 113,
            "KÃ¼snacht": 73, "MÃ¤nnedorf": 87, "Meilen": 79, "Oetwil a.S.": 114,
            "StÃ¤fa": 83, "Uetikon a.S.": 84, "Zumikon": 71, "Zollikon": 76,
            "Fehraltorf": 111, "Lindau": 106, "PfÃ¤ffikon": 110, "Russikon": 113,
            "Weisslingen": 116, "Wila": 122, "Wildberg": 124, "DÃ¼bendorf": 92,
            "Egg": 101, "FÃ¤llanden": 99, "Greifensee": 101, "Maur": 81,
            "MÃ¶nchaltorf": 108, "Schwerzenbach": 103, "Uster": 112, "Volketswil": 101,
            "Wangen-BrÃ¼ttisellen": 101, "Altikon": 114, "BrÃ¼tten": 85, "DÃ¤ttlikon": 112,
            "Dinhard": 90, "Ellikon a.d.Th.": 117, "Elsau": 117, "Hagenbuch": 121,
            "Hettlingen": 97, "Neftenbach": 98, "Pfungen": 112, "Rickenbach": 112,
            "Schlatt": 123, "Seuzach": 100, "Turbenthal": 122, "Winterthur": 125,
            "Zell": 115, "Aesch": 91, "Birmensdorf": 112, "Dietikon": 121,
            "Geroldswil": 112, "Oberengstringen": 109, "Oetwil a.d.L.": 107, "Schlieren": 111,
            "Uitikon": 78, "Unterengstringen": 102, "Urdorf": 115, "Weiningen": 107,
            "ZÃ¼rich": 119, "Andelfingen": 119, "Stammheim": 112, "WÃ¤denswil": 102,
            "Elgg": 119, "Horgen": 90, "Illnau-Effretikon": 113, "Bauma": 120,
            "Wiesendangen": 86
        };

        function formatDuration(seconds) {
            if (!Number.isFinite(seconds)) {
                return "â€”";
            }
            const minutes = Math.round(seconds / 60);
            if (minutes < 60) {
                return `${minutes}m`;
            }
            const hours = Math.floor(minutes / 60);
            const remaining = minutes % 60;
            return `${hours}h ${remaining}m`;
        }

        function getTimeColorClass(seconds, mode) {
            if (!Number.isFinite(seconds)) {
                return "";
            }
            const minutes = Math.round(seconds / 60);
            if (mode === "cycling") {
                // Bike: <30m green, 30-45m orange, >45m red
                if (minutes < 30) return "time-green";
                if (minutes <= 45) return "time-orange";
                return "time-red";
            } else {
                // Public transport and car: <30m green, 30-70m orange, >70m red
                if (minutes < 30) return "time-green";
                if (minutes <= 70) return "time-orange";
                return "time-red";
            }
        }

        function buildGoogleMapEmbed(query, lat, lng) {
            const zoom = 15;
            if (typeof lat === "number" && typeof lng === "number") {
                // Use precise coordinates to avoid Google interpreting the query as a directions request
                return `https://www.google.com/maps?q=${lat},${lng}&z=${zoom}&output=embed`;
            }
            return `https://www.google.com/maps?q=${encodeURIComponent(query)}&z=${zoom}&output=embed`;
        }

        function buildShadeMapLink(lat, lng) {
            return `https://shademap.app/@${lat},${lng},16z`;
        }

        // Convert WGS84 lat/lng to Swiss grid (LV03) then to LV95 used by schweizmobil link
        function wgs84ToSwissLV03(lat, lng) {
            const latSec = lat * 3600;
            const lngSec = lng * 3600;
            const latAux = (latSec - 169028.66) / 10000.0;
            const lngAux = (lngSec - 26782.5) / 10000.0;

            const x = 200147.07 + 308807.95 * latAux + 3745.25 * Math.pow(lngAux, 2) + 76.63 * Math.pow(latAux, 2) - 194.56 * Math.pow(lngAux, 2) * latAux + 119.79 * Math.pow(latAux, 3);
            const y = 600072.37 + 211455.93 * lngAux - 10938.51 * lngAux * latAux - 0.36 * lngAux * Math.pow(latAux, 2) - 44.54 * Math.pow(lngAux, 3);

            return { E: Math.round(y), N: Math.round(x) };
        }

        function wgs84ToSwissLV95(lat, lng) {
            const lv03 = wgs84ToSwissLV03(lat, lng);
            return { E: lv03.E + 2000000, N: lv03.N + 1000000 };
        }

        function buildSchweizmobilLink(lat, lng) {
            const coords = wgs84ToSwissLV95(lat, lng);
            // Template from user; ensure E and N values are set to LV95 coordinates
            return `https://schweizmobil.ch/de/map?season=summer&bgLayer=pk&layers=&detours=no&photos=no&logos=no&shooting=yes&resolution=4.60&E=${coords.E}&N=${coords.N}`;
        }

        function buildDirectionsLink(origin, destination, mode) {
            const base = "https://www.google.com/maps/dir/?api=1";
            const params = new URLSearchParams({
                origin,
                destination,
                travelmode: mode,
            });
            return `${base}&${params.toString()}`;
        }

        function normalizeQuery(value) {
            const trimmed = value.trim();
            if (!trimmed) {
                return "";
            }
            if (/switzerland/i.test(trimmed)) {
                return trimmed;
            }
            return `${trimmed}, Switzerland`;
        }

        async function geocode(query) {
            const response = await fetch(
                `https://nominatim.openstreetmap.org/search?format=json&limit=1&addressdetails=1&q=${encodeURIComponent(query)}`,
                { headers: { Accept: "application/json" } }
            );
            if (!response.ok) {
                throw new Error("Geocoding failed");
            }
            const data = await response.json();
            if (!data.length) {
                throw new Error("No results");
            }
            return {
                lat: Number.parseFloat(data[0].lat),
                lng: Number.parseFloat(data[0].lon),
                label: data[0].display_name,
            };
        }

        async function reverseGeocode(lat, lng) {
            const response = await fetch(
                `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&addressdetails=1`,
                { headers: { Accept: "application/json" } }
            );
            if (!response.ok) {
                throw new Error("Reverse geocoding failed");
            }
            const data = await response.json();
            if (!data.address) {
                throw new Error("No address found");
            }
            // Swiss municipalities can be in different fields depending on the location
            return data.address.municipality || data.address.city || data.address.town || data.address.village || null;
        }

        async function fetchOsrmRoute(origin, destination, profile = "driving") {
            const baseUrl = profile === "cycling"
                ? "https://routing.openstreetmap.de/routed-bike/route/v1/driving"
                : "https://routing.openstreetmap.de/routed-car/route/v1/driving";
            const url = `${baseUrl}/${origin.lng},${origin.lat};${destination.lng},${destination.lat}?overview=false`;
            const response = await fetch(url, { headers: { Accept: "application/json" } });
            if (!response.ok) {
                throw new Error("Routing failed");
            }
            const data = await response.json();
            if (!data.routes || !data.routes.length) {
                throw new Error("No route");
            }
            return { duration: data.routes[0].duration, distance: data.routes[0].distance };
        }

        async function fetchTransitDuration(origin, destination) {
            const params = new URLSearchParams({
                from: `${origin.lat},${origin.lng}`,
                to: `${destination.lat},${destination.lng}`,
                limit: "1",
            });
            const response = await fetch(`https://transport.opendata.ch/v1/connections?${params.toString()}`, {
                headers: { Accept: "application/json" },
            });
            if (!response.ok) {
                throw new Error("Transit fetch failed");
            }
            const data = await response.json();
            if (!data.connections || !data.connections.length) {
                throw new Error("No transit results");
            }
            return data.connections[0].duration;
        }

        function parseTransitDuration(durationText) {
            if (!durationText || typeof durationText !== "string") {
                return Number.NaN;
            }
            const match = durationText.match(/(\d+)d(\d+):(\d+):(\d+)/);
            if (!match) {
                return Number.NaN;
            }
            const days = Number(match[1]);
            const hours = Number(match[2]);
            const minutes = Number(match[3]);
            const seconds = Number(match[4]);
            return (((days * 24 + hours) * 60 + minutes) * 60) + seconds;
        }

        const travelModes = [
            { id: "transit", label: "ðŸšŒ", mapMode: "transit" },
            { id: "cycling", label: "ðŸš²", mapMode: "bicycling" },
            { id: "driving", label: "ðŸš—", mapMode: "driving" },
        ];

        function renderTravelTable() {
            travelTimesBody.innerHTML = "";
            destinations.forEach((destination) => {
                const row = document.createElement("tr");
                row.dataset.destinationId = destination.id;

                const nameCell = document.createElement("td");
                nameCell.className = "text-left";
                nameCell.textContent = destination.name;
                row.appendChild(nameCell);

                const bikeCell = document.createElement("td");
                bikeCell.dataset.mode = "cycling";
                bikeCell.textContent = "â€”";
                row.appendChild(bikeCell);

                const transitCell = document.createElement("td");
                transitCell.dataset.mode = "transit";
                transitCell.textContent = "â€”";
                row.appendChild(transitCell);

                const carCell = document.createElement("td");
                carCell.dataset.mode = "driving";
                carCell.textContent = "â€”";
                row.appendChild(carCell);

                travelTimesBody.appendChild(row);
            });

            // Add climbing gym row
            const gymRow = document.createElement("tr");
            gymRow.dataset.destinationId = "climbing-gym";

            const gymNameCell = document.createElement("td");
            gymNameCell.className = "text-left";
            gymNameCell.dataset.gymName = "true";
            gymNameCell.textContent = "ðŸ§— Nearest climbing gym";
            gymRow.appendChild(gymNameCell);

            const gymBikeCell = document.createElement("td");
            gymBikeCell.dataset.mode = "cycling";
            gymBikeCell.textContent = "â€”";
            gymRow.appendChild(gymBikeCell);

            const gymTransitCell = document.createElement("td");
            gymTransitCell.dataset.mode = "transit";
            gymTransitCell.textContent = "â€”";
            gymRow.appendChild(gymTransitCell);

            const gymCarCell = document.createElement("td");
            gymCarCell.dataset.mode = "driving";
            gymCarCell.textContent = "â€”";
            gymRow.appendChild(gymCarCell);

            travelTimesBody.appendChild(gymRow);
        }

        function renderMiscTable() {
            const tbody = document.getElementById("nearby-body");
            tbody.innerHTML = "";

            // Forest row
            const forestTr = document.createElement("tr");
            forestTr.dataset.miscRow = "forest";

            const forestEmojiTd = document.createElement("td");
            forestEmojiTd.textContent = "ðŸŒ²";
            forestTr.appendChild(forestEmojiTd);

            const forestLabelTd = document.createElement("td");
            forestLabelTd.className = "text-left";
            forestLabelTd.textContent = "Nearby forest";
            forestTr.appendChild(forestLabelTd);

            const forestInfoTd = document.createElement("td");
            forestInfoTd.dataset.forest = "combined";
            forestInfoTd.className = "status";
            forestInfoTd.textContent = "Loadingâ€¦";
            forestTr.appendChild(forestInfoTd);

            tbody.appendChild(forestTr);

            // Trail row
            const trailTr = document.createElement("tr");
            trailTr.dataset.miscRow = "trails";

            const trailEmojiTd = document.createElement("td");
            trailEmojiTd.textContent = "ðŸ¥¾";
            trailTr.appendChild(trailEmojiTd);

            const trailLabelTd = document.createElement("td");
            trailLabelTd.className = "text-left";
            trailLabelTd.textContent = "Trail density";
            trailTr.appendChild(trailLabelTd);

            const trailInfoTd = document.createElement("td");
            trailInfoTd.dataset.trails = "value";
            trailInfoTd.className = "status";
            trailInfoTd.textContent = "Loadingâ€¦";
            trailTr.appendChild(trailInfoTd);

            tbody.appendChild(trailTr);

            // Fog row
            const fogTr = document.createElement("tr");
            fogTr.dataset.miscRow = "fog";

            const fogEmojiTd = document.createElement("td");
            fogEmojiTd.textContent = "ðŸŒ«ï¸";
            fogTr.appendChild(fogEmojiTd);

            const fogLabelTd = document.createElement("td");
            fogLabelTd.className = "text-left";
            fogLabelTd.textContent = "Fog proneness";
            fogTr.appendChild(fogLabelTd);

            const fogInfoTd = document.createElement("td");
            fogInfoTd.dataset.fog = "value";
            fogInfoTd.className = "status";
            fogInfoTd.textContent = "Loadingâ€¦";
            fogTr.appendChild(fogInfoTd);

            tbody.appendChild(fogTr);

            // Tax multiplier row
            const taxTr = document.createElement("tr");
            taxTr.dataset.miscRow = "tax";

            const taxEmojiTd = document.createElement("td");
            taxEmojiTd.textContent = "ðŸ’°";
            taxTr.appendChild(taxEmojiTd);

            const taxLabelTd = document.createElement("td");
            taxLabelTd.className = "text-left";
            taxLabelTd.textContent = "Tax multiplier";
            taxTr.appendChild(taxLabelTd);

            const taxInfoTd = document.createElement("td");
            taxInfoTd.dataset.tax = "value";
            taxInfoTd.className = "status";
            taxInfoTd.textContent = "Loadingâ€¦";
            taxTr.appendChild(taxInfoTd);

            tbody.appendChild(taxTr);
        }

        function updateCellLink(cell, origin, destination, mode) {
            const link = cell.querySelector("a");
            if (!link) {
                return;
            }
            const originStr = `${origin.lat},${origin.lng}`;
            const destinationStr = destination.address;
            link.href = buildDirectionsLink(originStr, destinationStr, mode);
            link.target = "_blank";
            link.rel = "noopener";
            link.removeAttribute("aria-disabled");
        }

        async function ensureDestinationCoordinates(destination) {
            if (destination.lat && destination.lng) {
                return destination;
            }
            if (!destination.address) {
                return null;
            }
            try {
                const geocoded = await geocode(normalizeQuery(destination.address));
                destination.lat = geocoded.lat;
                destination.lng = geocoded.lng;
                return destination;
            } catch (error) {
                return null;
            }
        }

        function setCellStatus(cell, text, isDisabled) {
            const link = cell.querySelector("a");
            if (!link) {
                return;
            }
            link.textContent = text;
            if (isDisabled) {
                link.setAttribute("aria-disabled", "true");
                link.removeAttribute("href");
            }
        }

        async function updateTravelTimes(origin) {
            const rows = Array.from(travelTimesBody.querySelectorAll("tr[data-destination-id]"));
            rows.forEach((row) => {
                const cells = row.querySelectorAll("td[data-mode]");
                cells.forEach((cell) => {
                    cell.textContent = "Loadingâ€¦";
                    cell.className = "status";
                });
            });

            const resolvedDestinations = {};
            for (const destination of destinations) {
                resolvedDestinations[destination.id] = await ensureDestinationCoordinates(destination);
            }

            for (const destination of destinations) {
                const resolved = resolvedDestinations[destination.id];
                const row = travelTimesBody.querySelector(`tr[data-destination-id="${destination.id}"]`);
                if (!row) continue;

                const bikeCell = row.querySelector('td[data-mode="cycling"]');
                const transitCell = row.querySelector('td[data-mode="transit"]');
                const carCell = row.querySelector('td[data-mode="driving"]');

                if (!resolved) {
                    const message = destination.address ? "Not found" : "Add address";
                    [bikeCell, transitCell, carCell].forEach((cell) => {
                        if (cell) {
                            cell.textContent = message;
                            cell.className = "status";
                        }
                    });
                    continue;
                }

                try {
                    const [transitRaw, cyclingRoute, drivingRoute] = await Promise.all([
                        fetchTransitDuration(origin, resolved),
                        fetchOsrmRoute(origin, resolved, "cycling"),
                        fetchOsrmRoute(origin, resolved, "driving"),
                    ]);

                    const transitSeconds = parseTransitDuration(transitRaw);
                    const cyclingSeconds = cyclingRoute.duration;
                    const drivingSeconds = drivingRoute.duration;

                    const originStr = `${origin.lat},${origin.lng}`;
                    const destinationStr = resolved.address;

                    // Bike cell
                    if (bikeCell) {
                        bikeCell.innerHTML = "";
                        bikeCell.className = "";
                        const bikeLink = document.createElement("a");
                        bikeLink.className = `time-link ${getTimeColorClass(cyclingSeconds, "cycling")}`;
                        bikeLink.href = buildDirectionsLink(originStr, destinationStr, "bicycling");
                        bikeLink.target = "_blank";
                        bikeLink.rel = "noopener";
                        bikeLink.textContent = formatDuration(cyclingSeconds);
                        bikeCell.appendChild(bikeLink);
                    }

                    // Transit cell
                    if (transitCell) {
                        transitCell.innerHTML = "";
                        transitCell.className = "";
                        const transitLink = document.createElement("a");
                        transitLink.className = `time-link ${getTimeColorClass(transitSeconds, "transit")}`;
                        transitLink.href = buildDirectionsLink(originStr, destinationStr, "transit");
                        transitLink.target = "_blank";
                        transitLink.rel = "noopener";
                        transitLink.textContent = formatDuration(transitSeconds);
                        transitCell.appendChild(transitLink);
                    }

                    // Car cell
                    if (carCell) {
                        carCell.innerHTML = "";
                        carCell.className = "";
                        const carLink = document.createElement("a");
                        carLink.className = `time-link ${getTimeColorClass(drivingSeconds, "driving")}`;
                        carLink.href = buildDirectionsLink(originStr, destinationStr, "driving");
                        carLink.target = "_blank";
                        carLink.rel = "noopener";
                        carLink.textContent = formatDuration(drivingSeconds);
                        carCell.appendChild(carLink);
                    }
                } catch (error) {
                    [bikeCell, transitCell, carCell].forEach((cell) => {
                        if (cell) {
                            cell.textContent = "Unavailable";
                            cell.className = "status";
                        }
                    });
                }
            }
        }

        // --- Nearby climbing gyms ---
        const climbingGyms = [
            { name: "Gaswerk Schlieren", address: "Kohlestrasse 12b, 8952 Schlieren" },
            { name: "Gaswerk Milandia", address: "Im Grossriet, 8606 Greifensee" },
            { name: "Gaswerk WÃ¤denswil", address: "RÃ¼tihof 2, 8820 WÃ¤denswil" },
            { name: "Griffig Uster", address: "Hallenbadweg 2, 8610 Uster" },
            { name: "6a plus Winterthur", address: "Klosterstrasse 17, 8406 Winterthur" },
        ];

        function formatDistance(meters) {
            if (!Number.isFinite(meters)) return "â€”";
            return `${(meters / 1000).toFixed(1)} km`;
        }

        async function updateNearbyGyms(origin) {
            const tbody = document.getElementById("nearby-body");
            const gymRow = travelTimesBody.querySelector('tr[data-destination-id="climbing-gym"]');
            const gymNameCell = gymRow?.querySelector('td[data-gym-name="true"]');
            const gymBikeCell = gymRow?.querySelector('td[data-mode="cycling"]');
            const gymTransitCell = gymRow?.querySelector('td[data-mode="transit"]');
            const gymCarCell = gymRow?.querySelector('td[data-mode="driving"]');

            // Set loading state for gym row
            if (gymNameCell) gymNameCell.textContent = "ðŸ§— Nearest climbing gym";
            [gymBikeCell, gymTransitCell, gymCarCell].forEach((cell) => {
                if (cell) {
                    cell.textContent = "Loadingâ€¦";
                    cell.className = "status";
                }
            });

            // Reset loading state for misc rows
            const forestTd = tbody.querySelector('td[data-forest="combined"]');
            const trailTd = tbody.querySelector('td[data-trails="value"]');
            const fogTd = tbody.querySelector('td[data-fog="value"]');
            [forestTd, trailTd, fogTd].forEach((cell) => {
                if (cell) {
                    cell.textContent = "Loadingâ€¦";
                    cell.className = "status";
                }
            });

            try {
                // Geocode all gyms in parallel
                await Promise.all(climbingGyms.map((gym) => ensureDestinationCoordinates(gym)));

                // Fetch routes in parallel for gyms with valid coordinates
                const validGyms = climbingGyms.filter((gym) => gym.lat && gym.lng);
                const routePromises = validGyms.map(async (gym) => {
                    try {
                        const route = await fetchOsrmRoute(origin, gym);
                        return { gym, duration: route.duration, distance: route.distance };
                    } catch (e) {
                        console.warn(`Routing failed for ${gym.name}:`, e.message);
                        return null;
                    }
                });

                const results = (await Promise.all(routePromises)).filter(Boolean);
                if (!results.length) {
                    [gymBikeCell, gymTransitCell, gymCarCell].forEach((cell) => {
                        if (cell) {
                            cell.textContent = "Unavailable";
                            cell.className = "status";
                        }
                    });
                    return;
                }
                results.sort((a, b) => a.duration - b.duration);

                const closestGym = results[0];

                // Update gym name cell
                if (gymNameCell) gymNameCell.textContent = `ðŸ§— ${closestGym.gym.name}`;

                // Fetch all travel modes for the closest gym
                const originStr = `${origin.lat},${origin.lng}`;
                const destinationStr = closestGym.gym.address;

                const [transitRaw, cyclingRoute, drivingRoute] = await Promise.all([
                    fetchTransitDuration(origin, closestGym.gym),
                    fetchOsrmRoute(origin, closestGym.gym, "cycling"),
                    fetchOsrmRoute(origin, closestGym.gym, "driving"),
                ]);

                const transitSeconds = parseTransitDuration(transitRaw);
                const cyclingSeconds = cyclingRoute.duration;
                const drivingSeconds = drivingRoute.duration;

                // Bike cell
                if (gymBikeCell) {
                    gymBikeCell.innerHTML = "";
                    gymBikeCell.className = "";
                    const bikeLink = document.createElement("a");
                    bikeLink.className = `time-link ${getTimeColorClass(cyclingSeconds, "cycling")}`;
                    bikeLink.href = buildDirectionsLink(originStr, destinationStr, "bicycling");
                    bikeLink.target = "_blank";
                    bikeLink.rel = "noopener";
                    bikeLink.textContent = formatDuration(cyclingSeconds);
                    gymBikeCell.appendChild(bikeLink);
                }

                // Transit cell
                if (gymTransitCell) {
                    gymTransitCell.innerHTML = "";
                    gymTransitCell.className = "";
                    const transitLink = document.createElement("a");
                    transitLink.className = `time-link ${getTimeColorClass(transitSeconds, "transit")}`;
                    transitLink.href = buildDirectionsLink(originStr, destinationStr, "transit");
                    transitLink.target = "_blank";
                    transitLink.rel = "noopener";
                    transitLink.textContent = formatDuration(transitSeconds);
                    gymTransitCell.appendChild(transitLink);
                }

                // Car cell
                if (gymCarCell) {
                    gymCarCell.innerHTML = "";
                    gymCarCell.className = "";
                    const carLink = document.createElement("a");
                    carLink.className = `time-link ${getTimeColorClass(drivingSeconds, "driving")}`;
                    carLink.href = buildDirectionsLink(originStr, destinationStr, "driving");
                    carLink.target = "_blank";
                    carLink.rel = "noopener";
                    carLink.textContent = formatDuration(drivingSeconds);
                    gymCarCell.appendChild(carLink);
                }

            } catch (err) {
                [gymBikeCell, gymTransitCell, gymCarCell, forestTd, trailTd, fogTd].forEach((cell) => {
                    if (cell) {
                        cell.textContent = "Unavailable";
                        cell.className = "status";
                    }
                });
            }
        }

        // --- Nearby fog proneness ---
        async function estimateFogProneness(lat, lng) {
            if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
                throw new Error("Invalid coordinates");
            }

            const radiusMeters = 2000;
            const ringPoints = 8;
            const timeoutMs = 8000;

            const clamp = (x, a, b) => Math.max(a, Math.min(b, x));

            const haversineMeters = (aLat, aLng, bLat, bLng) => {
                const R = 6371000;
                const toRad = (d) => (d * Math.PI) / 180;
                const dLat = toRad(bLat - aLat);
                const dLng = toRad(bLng - aLng);
                const s1 = Math.sin(dLat / 2);
                const s2 = Math.sin(dLng / 2);
                const aa = s1 * s1 + Math.cos(toRad(aLat)) * Math.cos(toRad(bLat)) * s2 * s2;
                return 2 * R * Math.asin(Math.sqrt(aa));
            };

            const destinationPoint = (latDeg, lngDeg, bearingDeg, distanceM) => {
                const R = 6371000;
                const toRad = (d) => (d * Math.PI) / 180;
                const toDeg = (r) => (r * 180) / Math.PI;
                const Ï†1 = toRad(latDeg);
                const Î»1 = toRad(lngDeg);
                const Î¸ = toRad(bearingDeg);
                const Î´ = distanceM / R;
                const sinÏ†2 = Math.sin(Ï†1) * Math.cos(Î´) + Math.cos(Ï†1) * Math.sin(Î´) * Math.cos(Î¸);
                const Ï†2 = Math.asin(sinÏ†2);
                const y = Math.sin(Î¸) * Math.sin(Î´) * Math.cos(Ï†1);
                const x = Math.cos(Î´) - Math.sin(Ï†1) * sinÏ†2;
                const Î»2 = Î»1 + Math.atan2(y, x);
                return { lat: toDeg(Ï†2), lng: ((toDeg(Î»2) + 540) % 360) - 180 };
            };

            // Major Swiss lakes (rough centroids)
            const lakes = [
                { name: "Lake Geneva", lat: 46.45, lng: 6.6 },
                { name: "Lake Constance", lat: 47.6, lng: 9.4 },
                { name: "Lake NeuchÃ¢tel", lat: 46.9, lng: 6.85 },
                { name: "Lake Biel", lat: 47.1, lng: 7.2 },
                { name: "Lake Thun", lat: 46.73, lng: 7.65 },
                { name: "Lake Brienz", lat: 46.74, lng: 7.98 },
                { name: "Lake Lucerne", lat: 46.98, lng: 8.35 },
                { name: "Lake Zug", lat: 47.14, lng: 8.52 },
                { name: "Lake Zurich", lat: 47.27, lng: 8.7 },
                { name: "Lago Maggiore", lat: 46.15, lng: 8.65 },
                { name: "Lago di Lugano", lat: 46.0, lng: 8.95 },
            ];

            let nearestLake = { name: null, distanceM: Infinity };
            for (const lake of lakes) {
                const d = haversineMeters(lat, lng, lake.lat, lake.lng);
                if (d < nearestLake.distanceM) {
                    nearestLake = { name: lake.name, distanceM: d };
                }
            }

            // Build elevation sample points: center + ring
            const ring = [];
            for (let i = 0; i < ringPoints; i++) {
                ring.push(destinationPoint(lat, lng, (360 / ringPoints) * i, radiusMeters));
            }
            const samplePoints = [{ lat, lng }, ...ring];
            const lats = samplePoints.map((p) => p.lat.toFixed(6)).join(",");
            const lngs = samplePoints.map((p) => p.lng.toFixed(6)).join(",");

            let elevations = null;
            const demUrl = `https://api.open-meteo.com/v1/elevation?latitude=${lats}&longitude=${lngs}`;
            try {
                const ctrl = new AbortController();
                const timeout = setTimeout(() => ctrl.abort(), timeoutMs);
                const response = await fetch(demUrl, { signal: ctrl.signal });
                clearTimeout(timeout);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                if (!data || !Array.isArray(data.elevation)) throw new Error("Unexpected DEM response");
                elevations = data.elevation.filter((e) => Number.isFinite(e));
                if (elevations.length < samplePoints.length) throw new Error(`Missing elevations: got ${elevations.length}, need ${samplePoints.length}`);
            } catch (e) {
                console.warn("DEM fetch failed:", e.message);
                elevations = null;
            }

            // Scoring (0-100)
            let score = 0;
            const reasons = [];

            // Lake proximity (0-20 points)
            const lakeKm = nearestLake.distanceM / 1000;
            let lakePoints = 0;
            if (lakeKm <= 3) lakePoints = 20;
            else if (lakeKm <= 8) lakePoints = 14;
            else if (lakeKm <= 15) lakePoints = 8;
            else if (lakeKm <= 30) lakePoints = 3;
            score += lakePoints;
            if (lakePoints >= 8) {
                reasons.push(`Near ${nearestLake.name}`);
            }

            if (elevations) {
                const centerElev = elevations[0];
                const ringElevs = elevations.slice(1);
                const ringMean = ringElevs.reduce((a, b) => a + b, 0) / ringElevs.length;
                const bowlDepthM = ringMean - centerElev; // positive = lower than surroundings
                const reliefM = Math.max(...ringElevs) - Math.min(...ringElevs);

                // Elevation band (0-26 points) - lower elevations more fog-prone in Swiss Plateau
                let elevPoints = 0;
                if (centerElev < 500) elevPoints = 26;
                else if (centerElev < 700) elevPoints = 20;
                else if (centerElev < 1400) elevPoints = 14;
                else if (centerElev < 2000) elevPoints = 8;
                else elevPoints = 4;
                score += elevPoints;
                reasons.push(`${Math.round(centerElev)} m elevation`);

                // Bowl depth / cold-air pooling (âˆ’6 to 34 points)
                let bowlPoints = 0;
                if (bowlDepthM >= 40) bowlPoints = 34;
                else if (bowlDepthM >= 25) bowlPoints = 28;
                else if (bowlDepthM >= 15) bowlPoints = 20;
                else if (bowlDepthM >= 8) bowlPoints = 12;
                else if (bowlDepthM >= 3) bowlPoints = 6;
                else if (bowlDepthM <= -10) bowlPoints = -6; // ridge/exposed
                score += bowlPoints;
                if (bowlPoints >= 20) {
                    reasons.push("valley/basin terrain");
                } else if (bowlPoints <= -4) {
                    reasons.push("exposed/ridge terrain");
                }

                // Relief / terrain complexity (0-20 points)
                let reliefPoints = 0;
                if (reliefM >= 300) reliefPoints = 20;
                else if (reliefM >= 180) reliefPoints = 14;
                else if (reliefM >= 100) reliefPoints = 9;
                else if (reliefM >= 60) reliefPoints = 5;
                score += reliefPoints;
            } else {
                // Cannot calculate without elevation data
                return { unavailable: true };
            }

            score = clamp(Math.round(score), 0, 100);

            let rating, ratingClass;
            if (score >= 75) {
                rating = "High";
                ratingClass = "rating-bad";
            } else if (score >= 55) {
                rating = "Moderate-High";
                ratingClass = "rating-bad";
            } else if (score >= 35) {
                rating = "Moderate";
                ratingClass = "rating-moderate";
            } else {
                rating = "Low";
                ratingClass = "rating-good";
            }

            return { unavailable: false, rating, ratingClass, score, reasons };
        }

        async function updateFogProneness(origin) {
            const tbody = document.getElementById("nearby-body");
            const fogTd = tbody.querySelector('td[data-fog="value"]');
            if (!fogTd) return;

            fogTd.textContent = "Loadingâ€¦";

            try {
                const result = await estimateFogProneness(origin.lat, origin.lng);

                if (result.unavailable) {
                    fogTd.textContent = "No data";
                    return;
                }

                const reasonText = result.reasons.length ? result.reasons.join(", ") : "â€”";

                fogTd.textContent = `${result.rating} `;
                fogTd.classList.remove("status");
                fogTd.classList.add(result.ratingClass);

                const infoIcon = document.createElement("span");
                infoIcon.className = "info-tooltip";
                infoIcon.setAttribute("role", "button");
                infoIcon.setAttribute("tabindex", "0");
                infoIcon.setAttribute("aria-label", "More info");
                infoIcon.textContent = "\u24D8";

                const tooltipText = document.createElement("span");
                tooltipText.className = "tooltip-text";
                tooltipText.textContent = reasonText;
                infoIcon.appendChild(tooltipText);

                infoIcon.addEventListener("click", (e) => {
                    e.stopPropagation();
                    infoIcon.classList.toggle("active");
                });

                fogTd.appendChild(infoIcon);
            } catch (err) {
                console.warn("Fog estimate failed:", err.message);
                fogTd.textContent = "No data";
            }
        }

        // --- Nearby forest coverage ---
        function closeRing(coords) {
            if (coords.length >= 3 &&
                (coords[0][0] !== coords[coords.length - 1][0] ||
                    coords[0][1] !== coords[coords.length - 1][1])) {
                coords.push(coords[0]);
            }
            return coords;
        }

        async function updateNearbyForest(origin) {
            const tbody = document.getElementById("nearby-body");
            const combinedTd = tbody.querySelector('td[data-forest="combined"]');
            if (!combinedTd) return;

            combinedTd.textContent = "Loadingâ€¦";

            if (typeof turf === "undefined") {
                combinedTd.textContent = "No data";
                return;
            }

            const overpassQuery = `[out:json];(way["landuse"="forest"](around:3000,${origin.lat},${origin.lng});relation["landuse"="forest"](around:3000,${origin.lat},${origin.lng});way["natural"="wood"](around:3000,${origin.lat},${origin.lng});relation["natural"="wood"](around:3000,${origin.lat},${origin.lng}););out geom;`;

            try {
                const response = await fetch("https://overpass-api.de/api/interpreter", {
                    method: "POST",
                    body: new URLSearchParams({ data: overpassQuery }),
                    headers: { "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8" },
                });
                if (!response.ok) throw new Error("Overpass query failed");
                const data = await response.json();
                const elements = data.elements || [];

                const features = [];
                elements.forEach((el) => {
                    if (el.geometry && el.geometry.length) {
                        const coords = el.geometry.map((p) => [p.lon, p.lat]);
                        if (coords.length >= 3) {
                            closeRing(coords);
                            try {
                                features.push(turf.polygon([coords], { id: el.id, osmType: el.type }));
                            } catch (e) {
                                console.warn(`Invalid polygon geometry for element ${el.id}:`, e.message);
                            }
                        } else if (coords.length) {
                            try {
                                features.push(turf.lineString(coords, { id: el.id, osmType: el.type }));
                            } catch (e) {
                                console.warn(`Invalid lineString geometry for element ${el.id}:`, e.message);
                            }
                        }
                    } else if (el.type === "relation" && el.members) {
                        const rings = [];
                        el.members.forEach((m) => {
                            if (m.geometry && m.geometry.length) {
                                const c = m.geometry.map((p) => [p.lon, p.lat]);
                                if (c.length >= 3) {
                                    closeRing(c);
                                    rings.push(c);
                                }
                            }
                        });
                        if (rings.length) {
                            try {
                                features.push(turf.polygon(rings, { id: el.id, osmType: el.type }));
                            } catch (e) {
                                console.warn(`Invalid relation polygon for element ${el.id}:`, e.message);
                            }
                        }
                    }
                });

                const circle = turf.circle([origin.lng, origin.lat], 3000, { steps: 64, units: "meters" });
                const circleArea = turf.area(circle);

                let totalArea = 0;
                let largestPatchArea = 0;

                features.forEach((f) => {
                    try {
                        const inter = turf.intersect(f, circle);
                        if (inter) {
                            const patchArea = turf.area(inter);
                            totalArea += patchArea;
                            if (patchArea > largestPatchArea) {
                                largestPatchArea = patchArea;
                            }
                        }
                    } catch (e) {
                        console.warn("Forest calculation failed:", e.message);
                    }
                });

                const percent = circleArea > 0 ? (totalArea / circleArea) * 100 : 0;
                const largestPatchKm2 = largestPatchArea / 1e6;

                // Scoring: largest patch (50%), coverage (50%)
                let patchScore = 10;
                if (largestPatchKm2 >= 2) patchScore = 100;
                else if (largestPatchKm2 >= 1) patchScore = 70;
                else if (largestPatchKm2 >= 0.5) patchScore = 40;

                let coverageScore = 20;
                if (percent >= 20) coverageScore = 100;
                else if (percent >= 10) coverageScore = 60;

                const combinedScore = (patchScore * 0.5) + (coverageScore * 0.5);

                let forestRating, forestRatingClass;
                if (combinedScore >= 70) {
                    forestRating = "High";
                    forestRatingClass = "rating-good";
                } else if (combinedScore >= 40) {
                    forestRating = "Moderate";
                    forestRatingClass = "rating-moderate";
                } else {
                    forestRating = "Low";
                    forestRatingClass = "rating-bad";
                }

                // Build tooltip text
                const tooltipContent = `${largestPatchKm2.toFixed(1)} kmÂ² largest patch, ${percent.toFixed(0)}% coverage within 3 km`;

                combinedTd.textContent = `${forestRating} `;
                combinedTd.classList.remove("status");
                combinedTd.classList.add(forestRatingClass);
                combinedTd.removeAttribute("data-loading");

                const infoIcon = document.createElement("span");
                infoIcon.className = "info-tooltip";
                infoIcon.setAttribute("role", "button");
                infoIcon.setAttribute("tabindex", "0");
                infoIcon.setAttribute("aria-label", "More info");
                infoIcon.textContent = "\u24D8";

                const tooltipText = document.createElement("span");
                tooltipText.className = "tooltip-text";
                tooltipText.textContent = tooltipContent;
                infoIcon.appendChild(tooltipText);

                infoIcon.addEventListener("click", (e) => {
                    e.stopPropagation();
                    infoIcon.classList.toggle("active");
                });

                combinedTd.appendChild(infoIcon);
            } catch (err) {
                combinedTd.textContent = "No data";
            }
        }

        // --- Trail density ---
        async function updateTrailDensity(origin) {
            const tbody = document.getElementById("nearby-body");
            const trailTd = tbody.querySelector('td[data-trails="value"]');
            if (!trailTd) return;

            trailTd.textContent = "Loadingâ€¦";

            if (typeof turf === "undefined") {
                trailTd.textContent = "No data";
                return;
            }

            // Query trails: track and bridleway only (forest/farm roads, excluding urban paths)
            const overpassQuery = `[out:json];(way["highway"="track"](around:2000,${origin.lat},${origin.lng});way["highway"="bridleway"](around:2000,${origin.lat},${origin.lng}););out geom;`;

            try {
                const response = await fetch("https://overpass-api.de/api/interpreter", {
                    method: "POST",
                    body: new URLSearchParams({ data: overpassQuery }),
                    headers: { "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8" },
                });
                if (!response.ok) throw new Error("Overpass query failed");
                const data = await response.json();
                const elements = data.elements || [];

                const originPoint = turf.point([origin.lng, origin.lat]);
                const radiusKm = 2;

                let totalLengthKm = 0;
                const typeCounts = {};
                elements.forEach((el) => {
                    const hwType = el.tags?.highway || "unknown";
                    typeCounts[hwType] = (typeCounts[hwType] || 0) + 1;
                    if (el.geometry && el.geometry.length >= 2) {
                        try {
                            const coords = el.geometry.map((p) => [p.lon, p.lat]);
                            // Sum length of segments where both endpoints are within radius
                            for (let i = 0; i < coords.length - 1; i++) {
                                const p1 = turf.point(coords[i]);
                                const p2 = turf.point(coords[i + 1]);
                                const d1 = turf.distance(originPoint, p1, { units: "kilometers" });
                                const d2 = turf.distance(originPoint, p2, { units: "kilometers" });
                                if (d1 <= radiusKm && d2 <= radiusKm) {
                                    totalLengthKm += turf.distance(p1, p2, { units: "kilometers" });
                                }
                            }
                        } catch (e) {
                            console.warn("Trail length calculation failed:", e.message);
                        }
                    }
                });

                console.log("Trail types found:", typeCounts);
                console.log("Total trail length:", totalLengthKm.toFixed(1), "km");

                let trailRating, trailRatingClass;
                if (totalLengthKm >= 30) {
                    trailRating = "High";
                    trailRatingClass = "rating-good";
                } else if (totalLengthKm >= 10) {
                    trailRating = "Moderate";
                    trailRatingClass = "rating-moderate";
                } else {
                    trailRating = "Low";
                    trailRatingClass = "rating-bad";
                }

                trailTd.textContent = `${trailRating} `;
                trailTd.classList.remove("status");
                trailTd.classList.add(trailRatingClass);

                const infoIcon = document.createElement("span");
                infoIcon.className = "info-tooltip";
                infoIcon.setAttribute("role", "button");
                infoIcon.setAttribute("tabindex", "0");
                infoIcon.setAttribute("aria-label", "More info");
                infoIcon.textContent = "\u24D8";

                const tooltipText = document.createElement("span");
                tooltipText.className = "tooltip-text";
                tooltipText.textContent = `${totalLengthKm.toFixed(0)} km of trails within 2 km`;
                infoIcon.appendChild(tooltipText);

                infoIcon.addEventListener("click", (e) => {
                    e.stopPropagation();
                    infoIcon.classList.toggle("active");
                });

                trailTd.appendChild(infoIcon);
            } catch (err) {
                console.warn("Trail density failed:", err.message);
                trailTd.textContent = "No data";
            }
        }

        async function updateTaxMultiplier(origin) {
            const tbody = document.getElementById("nearby-body");
            const taxTd = tbody.querySelector('td[data-tax="value"]');
            if (!taxTd) return;

            taxTd.textContent = "Loadingâ€¦";
            taxTd.className = "status";

            try {
                const municipality = await reverseGeocode(origin.lat, origin.lng);
                if (!municipality) {
                    taxTd.textContent = "Unknown municipality";
                    return;
                }

                // Try to find matching municipality in tax data
                let multiplier = taxMultipliers[municipality];
                let matchedName = municipality;

                if (multiplier === undefined) {
                    // Build searchable name: normalize umlauts and convert abbreviations
                    const searchName = municipality
                        .replace(/Ã¼/g, "u").replace(/Ãœ/g, "U")
                        .replace(/Ã¤/g, "a").replace(/Ã„/g, "A")
                        .replace(/Ã¶/g, "o").replace(/Ã–/g, "O")
                        .replace(/ am Albis$/i, "")
                        .replace(/ am Irchel$/i, "")
                        .replace(/ an der Thur$/i, "")
                        .replace(/ am See$/i, "")
                        .replace(/ an der Limmat$/i, "")
                        .toLowerCase();

                    // Search through tax data keys
                    for (const [name, value] of Object.entries(taxMultipliers)) {
                        const compareName = name
                            .replace(/Ã¼/g, "u").replace(/Ãœ/g, "U")
                            .replace(/Ã¤/g, "a").replace(/Ã„/g, "A")
                            .replace(/Ã¶/g, "o").replace(/Ã–/g, "O")
                            .replace(/ a\.A\.$/i, "")
                            .replace(/ a\.I\.$/i, "")
                            .replace(/ a\.d\.Th\.$/i, "")
                            .replace(/ a\.S\.$/i, "")
                            .replace(/ a\.d\.L\.$/i, "")
                            .toLowerCase();

                        if (searchName === compareName) {
                            multiplier = value;
                            matchedName = name;
                            break;
                        }
                    }
                }

                if (multiplier === undefined) {
                    taxTd.textContent = `${municipality} (no data)`;
                    taxTd.className = "status";
                    return;
                }

                // Color based on multiplier value (lower is better)
                let ratingClass;
                if (multiplier <= 85) {
                    ratingClass = "rating-good";
                } else if (multiplier <= 110) {
                    ratingClass = "rating-moderate";
                } else {
                    ratingClass = "rating-bad";
                }

                taxTd.textContent = `${multiplier}% `;
                taxTd.classList.remove("status");
                taxTd.classList.add(ratingClass);

                const infoIcon = document.createElement("span");
                infoIcon.className = "info-tooltip";
                infoIcon.setAttribute("role", "button");
                infoIcon.setAttribute("tabindex", "0");
                infoIcon.setAttribute("aria-label", "More info");
                infoIcon.textContent = "\u24D8";

                const tooltipText = document.createElement("span");
                tooltipText.className = "tooltip-text";
                tooltipText.textContent = `Gemeinde: ${matchedName}`;
                infoIcon.appendChild(tooltipText);

                infoIcon.addEventListener("click", (e) => {
                    e.stopPropagation();
                    infoIcon.classList.toggle("active");
                });

                taxTd.appendChild(infoIcon);
            } catch (err) {
                console.warn("Tax multiplier lookup failed:", err.message);
                taxTd.textContent = "No data";
            }
        }

        async function handleSearch() {
            const query = normalizeQuery(addressInput.value);
            if (!query) {
                searchStatus.textContent = "";
                return;
            }
            searchStatus.textContent = "Searchingâ€¦";
            searchButton.disabled = true;

            // Reset Miscellaneous table to loading state immediately
            const miscBody = document.getElementById("nearby-body");
            miscBody.querySelectorAll('td[data-forest], td[data-trails], td[data-fog], td[data-tax]').forEach((cell) => {
                cell.textContent = "Loadingâ€¦";
                cell.className = "status";
            });

            try {
                const result = await geocode(query);
                const origin = { lat: result.lat, lng: result.lng };
                // Prefer embedding by coordinates to show the location pin only
                mapFrame.src = buildGoogleMapEmbed(result.label, result.lat, result.lng);
                shadeLink.href = buildShadeMapLink(result.lat, result.lng);
                if (typeof schweizLink !== "undefined" && schweizLink) {
                    schweizLink.href = buildSchweizmobilLink(result.lat, result.lng);
                }
                searchStatus.textContent = query;
                await updateTravelTimes(origin);
                await updateNearbyGyms(origin);
                await updateNearbyForest(origin);
                await updateFogProneness(origin);
                await updateTrailDensity(origin);
                await updateTaxMultiplier(origin);
            } catch (error) {
                searchStatus.textContent = "No results found. Try a more specific address.";
            } finally {
                searchButton.disabled = false;
            }
        }

        searchButton.addEventListener("click", () => {
            handleSearch();
        });

        document.getElementById("clear-button").addEventListener("click", () => {
            addressInput.value = "";
            addressInput.focus();
        });

        addressInput.addEventListener("keydown", (event) => {
            if (event.key === "Enter") {
                handleSearch();
            }
        });

        renderTravelTable();
        renderMiscTable();

        // Close tooltips when clicking elsewhere
        document.addEventListener("click", () => {
            document.querySelectorAll(".info-tooltip.active").forEach((el) => {
                el.classList.remove("active");
            });
        });

        // Load default address on page load
        addressInput.value = "Freilagerstrasse 99, 8047 ZÃ¼rich";
        handleSearch();
    </script>
</body>

</html>