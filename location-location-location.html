<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Location, Location, Location</title>
    <style>
        :root {
            --color-primary: #1a73e8;
            --color-text: #1f2a37;
            --color-text-muted: #6b7280;
            --color-border: #d1d7e0;
            --color-bg: #f5f6f8;
            --color-card: #ffffff;
            font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
        }

        body {
            margin: 0;
            background: var(--color-bg);
            color: var(--color-text);
        }

        main {
            max-width: 720px;
            margin: 0 auto;
            padding: 20px 16px 40px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        h1 {
            font-size: 1.6rem;
            margin: 0;
        }

        p {
            margin: 0;
            line-height: 1.4;
        }

        .card {
            background: var(--color-card);
            border-radius: 14px;
            padding: 16px;
            box-shadow: 0 6px 18px rgba(18, 24, 40, 0.08);
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        label {
            font-weight: 600;
        }

        input[type="text"] {
            flex: 1;
            padding: 12px 14px;
            border-radius: 10px;
            border: 1px solid var(--color-border);
            font-size: 1rem;
            background: var(--color-card);
            color: inherit;
        }

        button {
            padding: 12px 16px;
            border-radius: 10px;
            border: none;
            background: var(--color-primary);
            color: #ffffff;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .row {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .map-frame {
            width: 100%;
            min-height: 260px;
            border: none;
            border-radius: 12px;
            background: #e2e8f0;
        }

        .link-box a {
            color: var(--color-primary);
            word-break: break-all;
        }

        .status {
            font-size: 0.9rem;
            color: var(--color-text-muted);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.95rem;
            table-layout: fixed;
        }

        th,
        td {
            text-align: center;
            padding: 8px 0;
            border-bottom: 1px solid #e5e7eb;
        }

        th {
            font-weight: 600;
            color: #4b5563;
        }

        th:first-child {
            width: 60px;
        }

        th:nth-child(2),
        th:nth-child(3),
        th:nth-child(4) {
            width: calc((100% - 60px) / 3);
        }

        .table-wrapper {
            overflow-x: auto;
        }

        .time-link {
            color: var(--color-primary);
            text-decoration: none;
            font-weight: 600;
        }

        .time-link[aria-disabled="true"] {
            color: #9ca3af;
            pointer-events: none;
        }

        .text-left {
            text-align: left;
            padding-left: 8px;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        .info-tooltip {
            position: relative;
            display: inline-block;
            margin-left: 4px;
            cursor: help;
            color: var(--color-text-muted);
            font-size: 0.85em;
        }

        .info-tooltip .tooltip-text {
            visibility: hidden;
            opacity: 0;
            position: absolute;
            bottom: 125%;
            right: 0;
            background: var(--color-text);
            color: var(--color-card);
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 0.85rem;
            white-space: nowrap;
            z-index: 10;
            transition: opacity 0.2s;
        }

        .info-tooltip .tooltip-text::after {
            content: "";
            position: absolute;
            top: 100%;
            right: 8px;
            border: 5px solid transparent;
            border-top-color: var(--color-text);
        }

        .info-tooltip:hover .tooltip-text,
        .info-tooltip.active .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        .rating-good {
            color: #16a34a;
            font-weight: 600;
        }

        .rating-moderate {
            color: #d97706;
            font-weight: 600;
        }

        .rating-bad {
            color: #dc2626;
            font-weight: 600;
        }

        @media (min-width: 600px) {
            .row {
                flex-direction: row;
                align-items: flex-end;
            }

            .row button {
                flex: 0 0 150px;
            }
        }
    </style>
</head>

<body>
    <main>
        <header class="card">
            <h1>Location, Location, Location</h1>
        </header>

        <section class="card">
            <h2>Address</h2>
            <div class="row">
                <input id="address" type="text" placeholder="e.g. Freilagerstrasse 99, 8047 Z√ºrich" />
                <button id="search-button" aria-label="Search for address">Search</button>
            </div>
            <p class="status" id="search-status">Enter an address to begin.</p>
        </section>

        <section class="card">
            <h2>Map</h2>
            <iframe id="map-frame" class="map-frame" title="Google map" loading="lazy"></iframe>
            <div class="link-box">
                <strong>Additional maps:</strong>
                <ul>
                    <li><a id="shade-link" href="https://shademap.app/" target="_blank" rel="noopener">ShadeMap</a></li>
                    <li><a id="schweiz-link"
                            href="https://schweizmobil.ch/de/map?season=summer&bgLayer=pk&layers=&detours=no&photos=no&logos=no&shooting=yes&resolution=4.60&E=2679220&N=1247867"
                            target="_blank" rel="noopener">SchweizMobil</a></li>
                </ul>
            </div>
        </section>

        <section class="card">
            <h2>Travel times</h2>
            <div class="table-wrapper">
                <table>
                    <thead>
                        <tr>
                            <th><span class="sr-only">Travel mode</span></th>
                            <th>Zurich HB</th>
                            <th>USZ</th>
                            <th>Sensirion</th>
                        </tr>
                    </thead>
                    <tbody id="travel-times-body"></tbody>
                </table>
            </div>
            <p class="status">Estimates only &#8594; Click the links for live data</p>
        </section>

        <section class="card">
            <h2>Nearby</h2>
            <div class="table-wrapper">
                <table>
                    <tbody id="nearby-body">
                        <tr>
                            <td colspan="3" class="status">Checking location‚Ä¶</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
    <script>
        const addressInput = document.getElementById("address");
        const searchButton = document.getElementById("search-button");
        const searchStatus = document.getElementById("search-status");
        const mapFrame = document.getElementById("map-frame");
        const shadeLink = document.getElementById("shade-link");
        const schweizLink = document.getElementById("schweiz-link");
        const travelTimesBody = document.getElementById("travel-times-body");

        const destinations = [
            {
                id: "zh",
                name: "Z√ºrich HB",
                address: "Zurich HB, Bahnhofplatz, 8001 Z√ºrich",
                lat: 47.378177,
                lng: 8.540192,
            },
            {
                id: "usz",
                name: "USZ",
                address: "University Hospital of Z√ºrich, R√§mistrasse 100, 8091 Z√ºrich",
                lat: 47.3766194,
                lng: 8.5465972,
            },
            {
                id: "sensirion",
                name: "Sensirion",
                address: "Sensirion AG, Laubisr√ºtistrasse 50, 8712 St√§fa",
                lat: 47.2379872,
                lng: 8.7447918,
            }
        ];

        function formatDuration(seconds) {
            if (!Number.isFinite(seconds)) {
                return "‚Äî";
            }
            const minutes = Math.round(seconds / 60);
            if (minutes < 60) {
                return `${minutes}m`;
            }
            const hours = Math.floor(minutes / 60);
            const remaining = minutes % 60;
            return `${hours}h ${remaining}m`;
        }

        function buildGoogleMapEmbed(query, lat, lng) {
            const zoom = 15;
            if (typeof lat === "number" && typeof lng === "number") {
                // Use precise coordinates to avoid Google interpreting the query as a directions request
                return `https://www.google.com/maps?q=${lat},${lng}&z=${zoom}&output=embed`;
            }
            return `https://www.google.com/maps?q=${encodeURIComponent(query)}&z=${zoom}&output=embed`;
        }

        function buildShadeMapLink(lat, lng) {
            return `https://shademap.app/@${lat},${lng},16z`;
        }

        // Convert WGS84 lat/lng to Swiss grid (LV03) then to LV95 used by schweizmobil link
        function wgs84ToSwissLV03(lat, lng) {
            const latSec = lat * 3600;
            const lngSec = lng * 3600;
            const latAux = (latSec - 169028.66) / 10000.0;
            const lngAux = (lngSec - 26782.5) / 10000.0;

            const x = 200147.07 + 308807.95 * latAux + 3745.25 * Math.pow(lngAux, 2) + 76.63 * Math.pow(latAux, 2) - 194.56 * Math.pow(lngAux, 2) * latAux + 119.79 * Math.pow(latAux, 3);
            const y = 600072.37 + 211455.93 * lngAux - 10938.51 * lngAux * latAux - 0.36 * lngAux * Math.pow(latAux, 2) - 44.54 * Math.pow(lngAux, 3);

            return { E: Math.round(y), N: Math.round(x) };
        }

        function wgs84ToSwissLV95(lat, lng) {
            const lv03 = wgs84ToSwissLV03(lat, lng);
            return { E: lv03.E + 2000000, N: lv03.N + 1000000 };
        }

        function buildSchweizmobilLink(lat, lng) {
            const coords = wgs84ToSwissLV95(lat, lng);
            // Template from user; ensure E and N values are set to LV95 coordinates
            return `https://schweizmobil.ch/de/map?season=summer&bgLayer=pk&layers=&detours=no&photos=no&logos=no&shooting=yes&resolution=4.60&E=${coords.E}&N=${coords.N}`;
        }

        function buildDirectionsLink(origin, destination, mode) {
            const base = "https://www.google.com/maps/dir/?api=1";
            const params = new URLSearchParams({
                origin,
                destination,
                travelmode: mode,
            });
            return `${base}&${params.toString()}`;
        }

        function normalizeQuery(value) {
            const trimmed = value.trim();
            if (!trimmed) {
                return "";
            }
            if (/switzerland/i.test(trimmed)) {
                return trimmed;
            }
            return `${trimmed}, Switzerland`;
        }

        async function geocode(query) {
            const response = await fetch(
                `https://nominatim.openstreetmap.org/search?format=json&limit=1&addressdetails=1&q=${encodeURIComponent(query)}`,
                { headers: { Accept: "application/json" } }
            );
            if (!response.ok) {
                throw new Error("Geocoding failed");
            }
            const data = await response.json();
            if (!data.length) {
                throw new Error("No results");
            }
            return {
                lat: Number.parseFloat(data[0].lat),
                lng: Number.parseFloat(data[0].lon),
                label: data[0].display_name,
            };
        }

        async function fetchOsrmRoute(origin, destination, profile = "driving") {
            const baseUrl = profile === "cycling"
                ? "https://routing.openstreetmap.de/routed-bike/route/v1/driving"
                : "https://routing.openstreetmap.de/routed-car/route/v1/driving";
            const url = `${baseUrl}/${origin.lng},${origin.lat};${destination.lng},${destination.lat}?overview=false`;
            const response = await fetch(url, { headers: { Accept: "application/json" } });
            if (!response.ok) {
                throw new Error("Routing failed");
            }
            const data = await response.json();
            if (!data.routes || !data.routes.length) {
                throw new Error("No route");
            }
            return { duration: data.routes[0].duration, distance: data.routes[0].distance };
        }

        async function fetchTransitDuration(origin, destination) {
            const params = new URLSearchParams({
                from: `${origin.lat},${origin.lng}`,
                to: `${destination.lat},${destination.lng}`,
                limit: "1",
            });
            const response = await fetch(`https://transport.opendata.ch/v1/connections?${params.toString()}`, {
                headers: { Accept: "application/json" },
            });
            if (!response.ok) {
                throw new Error("Transit fetch failed");
            }
            const data = await response.json();
            if (!data.connections || !data.connections.length) {
                throw new Error("No transit results");
            }
            return data.connections[0].duration;
        }

        function parseTransitDuration(durationText) {
            if (!durationText || typeof durationText !== "string") {
                return Number.NaN;
            }
            const match = durationText.match(/(\d+)d(\d+):(\d+):(\d+)/);
            if (!match) {
                return Number.NaN;
            }
            const days = Number(match[1]);
            const hours = Number(match[2]);
            const minutes = Number(match[3]);
            const seconds = Number(match[4]);
            return (((days * 24 + hours) * 60 + minutes) * 60) + seconds;
        }

        const travelModes = [
            { id: "transit", label: "üöå", mapMode: "transit" },
            { id: "cycling", label: "üö≤", mapMode: "bicycling" },
            { id: "driving", label: "üöó", mapMode: "driving" },
        ];

        function renderTravelTable() {
            travelTimesBody.innerHTML = "";
            travelModes.forEach((mode) => {
                const row = document.createElement("tr");
                row.dataset.mode = mode.id;

                const labelCell = document.createElement("td");
                labelCell.textContent = mode.label;
                row.appendChild(labelCell);

                destinations.forEach((destination) => {
                    const cell = document.createElement("td");
                    cell.dataset.destinationId = destination.id;
                    cell.dataset.mode = mode.id;

                    const link = document.createElement("a");
                    link.className = "time-link";
                    link.href = "#";
                    link.textContent = "‚Äî";
                    link.setAttribute("aria-disabled", "true");

                    cell.appendChild(link);
                    row.appendChild(cell);
                });

                travelTimesBody.appendChild(row);
            });
        }

        function updateCellLink(cell, origin, destination, mode) {
            const link = cell.querySelector("a");
            if (!link) {
                return;
            }
            const originStr = `${origin.lat},${origin.lng}`;
            const destinationStr = destination.address;
            link.href = buildDirectionsLink(originStr, destinationStr, mode);
            link.target = "_blank";
            link.rel = "noopener";
            link.removeAttribute("aria-disabled");
        }

        async function ensureDestinationCoordinates(destination) {
            if (destination.lat && destination.lng) {
                return destination;
            }
            if (!destination.address) {
                return null;
            }
            try {
                const geocoded = await geocode(normalizeQuery(destination.address));
                destination.lat = geocoded.lat;
                destination.lng = geocoded.lng;
                return destination;
            } catch (error) {
                return null;
            }
        }

        function setCellStatus(cell, text, isDisabled) {
            const link = cell.querySelector("a");
            if (!link) {
                return;
            }
            link.textContent = text;
            if (isDisabled) {
                link.setAttribute("aria-disabled", "true");
                link.removeAttribute("href");
            }
        }

        async function updateTravelTimes(origin) {
            const cells = Array.from(travelTimesBody.querySelectorAll("td[data-destination-id]"));
            cells.forEach((cell) => {
                setCellStatus(cell, "Loading‚Ä¶", true);
            });

            const resolvedDestinations = {};
            for (const destination of destinations) {
                resolvedDestinations[destination.id] = await ensureDestinationCoordinates(destination);
            }

            for (const destination of destinations) {
                const resolved = resolvedDestinations[destination.id];
                const destinationCells = cells.filter((cell) => cell.dataset.destinationId === destination.id);
                if (!resolved) {
                    destinationCells.forEach((cell) => {
                        setCellStatus(cell, destination.address ? "Not found" : "Add address", true);
                    });
                    continue;
                }

                try {
                    const [transitRaw, cyclingRoute, drivingRoute] = await Promise.all([
                        fetchTransitDuration(origin, resolved),
                        fetchOsrmRoute(origin, resolved, "cycling"),
                        fetchOsrmRoute(origin, resolved, "driving"),
                    ]);

                    const transitSeconds = parseTransitDuration(transitRaw);
                    const durations = {
                        transit: formatDuration(transitSeconds),
                        cycling: formatDuration(cyclingRoute.duration),
                        driving: formatDuration(drivingRoute.duration),
                    };

                    destinationCells.forEach((cell) => {
                        const mode = cell.dataset.mode;
                        setCellStatus(cell, durations[mode] ?? "‚Äî", false);
                        const mapMode = travelModes.find((item) => item.id === mode)?.mapMode;
                        if (mapMode) {
                            updateCellLink(cell, origin, resolved, mapMode);
                        }
                    });
                } catch (error) {
                    destinationCells.forEach((cell) => {
                        setCellStatus(cell, "Unavailable", true);
                    });
                }
            }
        }

        // --- Nearby climbing gyms ---
        const climbingGyms = [
            { name: "Gaswerk Schlieren", address: "Kohlestrasse 12b, 8952 Schlieren" },
            { name: "Gaswerk Milandia", address: "Im Grossriet, 8606 Greifensee" },
            { name: "Gaswerk W√§denswil", address: "R√ºtihof 2, 8820 W√§denswil" },
            { name: "Griffig Uster", address: "Hallenbadweg 2, 8610 Uster" },
            { name: "6a plus Winterthur", address: "Klosterstrasse 17, 8406 Winterthur" },
        ];

        function formatDistance(meters) {
            if (!Number.isFinite(meters)) return "‚Äî";
            return `${(meters / 1000).toFixed(1)} km`;
        }

        async function updateNearbyGyms(origin) {
            const tbody = document.getElementById("nearby-body");
            tbody.innerHTML = `<tr><td colspan="3" class="status">Checking nearby‚Ä¶</td></tr>`;
            try {
                // Geocode all gyms in parallel
                await Promise.all(climbingGyms.map((gym) => ensureDestinationCoordinates(gym)));

                // Fetch routes in parallel for gyms with valid coordinates
                const validGyms = climbingGyms.filter((gym) => gym.lat && gym.lng);
                const routePromises = validGyms.map(async (gym) => {
                    try {
                        const route = await fetchOsrmRoute(origin, gym);
                        return { gym, duration: route.duration, distance: route.distance };
                    } catch (e) {
                        console.warn(`Routing failed for ${gym.name}:`, e.message);
                        return null;
                    }
                });

                const results = (await Promise.all(routePromises)).filter(Boolean);
                if (!results.length) {
                    tbody.innerHTML = `<tr><td colspan="3" class="status">No route information available.</td></tr>`;
                    return;
                }
                results.sort((a, b) => a.duration - b.duration);

                const closestGym = results[0];
                tbody.innerHTML = "";
                const tr = document.createElement("tr");

                const emojiTd = document.createElement("td");
                emojiTd.textContent = "üßó";
                tr.appendChild(emojiTd);

                const nameTd = document.createElement("td");
                nameTd.textContent = closestGym.gym.name;
                nameTd.className = "text-left";
                tr.appendChild(nameTd);

                const infoTd = document.createElement("td");
                const link = document.createElement("a");
                link.className = "time-link";
                link.target = "_blank";
                link.rel = "noopener";
                link.href = buildDirectionsLink(`${origin.lat},${origin.lng}`, `${closestGym.gym.lat},${closestGym.gym.lng}`, "driving");
                link.textContent = `${formatDistance(closestGym.distance)} ¬∑ ${formatDuration(closestGym.duration)} üöó`;
                infoTd.appendChild(link);
                tr.appendChild(infoTd);

                tbody.appendChild(tr);

                const forestEmojiTd = document.createElement("td");
                forestEmojiTd.textContent = "üå≤";

                const forestLabelTd = document.createElement("td");

                const forestInfoTd = document.createElement("td");
                forestInfoTd.dataset.forest = "combined";
                forestInfoTd.dataset.loading = "true";
                forestInfoTd.className = "status";
                forestInfoTd.textContent = "Loading‚Ä¶";

                const forestTr = document.createElement("tr");
                forestTr.dataset.forestRow = "combined";
                forestTr.appendChild(forestEmojiTd);
                forestTr.appendChild(forestLabelTd);
                forestTr.appendChild(forestInfoTd);

                tbody.appendChild(forestTr);

                const fogEmojiTd = document.createElement("td");
                fogEmojiTd.textContent = "üå´Ô∏è";

                const fogLabelTd = document.createElement("td");

                const fogInfoTd = document.createElement("td");
                fogInfoTd.dataset.fog = "value";
                fogInfoTd.className = "status";
                fogInfoTd.textContent = "Loading‚Ä¶";

                const fogTr = document.createElement("tr");
                fogTr.appendChild(fogEmojiTd);
                fogTr.appendChild(fogLabelTd);
                fogTr.appendChild(fogInfoTd);

                tbody.appendChild(fogTr);
            } catch (err) {
                tbody.innerHTML = `<tr><td colspan="3" class="status">Unable to determine nearby gyms.</td></tr>`;
            }
        }

        // --- Nearby fog proneness ---
        async function estimateFogProneness(lat, lng) {
            if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
                throw new Error("Invalid coordinates");
            }

            const radiusMeters = 2000;
            const ringPoints = 8;
            const timeoutMs = 8000;

            const clamp = (x, a, b) => Math.max(a, Math.min(b, x));

            const haversineMeters = (aLat, aLng, bLat, bLng) => {
                const R = 6371000;
                const toRad = (d) => (d * Math.PI) / 180;
                const dLat = toRad(bLat - aLat);
                const dLng = toRad(bLng - aLng);
                const s1 = Math.sin(dLat / 2);
                const s2 = Math.sin(dLng / 2);
                const aa = s1 * s1 + Math.cos(toRad(aLat)) * Math.cos(toRad(bLat)) * s2 * s2;
                return 2 * R * Math.asin(Math.sqrt(aa));
            };

            const destinationPoint = (latDeg, lngDeg, bearingDeg, distanceM) => {
                const R = 6371000;
                const toRad = (d) => (d * Math.PI) / 180;
                const toDeg = (r) => (r * 180) / Math.PI;
                const œÜ1 = toRad(latDeg);
                const Œª1 = toRad(lngDeg);
                const Œ∏ = toRad(bearingDeg);
                const Œ¥ = distanceM / R;
                const sinœÜ2 = Math.sin(œÜ1) * Math.cos(Œ¥) + Math.cos(œÜ1) * Math.sin(Œ¥) * Math.cos(Œ∏);
                const œÜ2 = Math.asin(sinœÜ2);
                const y = Math.sin(Œ∏) * Math.sin(Œ¥) * Math.cos(œÜ1);
                const x = Math.cos(Œ¥) - Math.sin(œÜ1) * sinœÜ2;
                const Œª2 = Œª1 + Math.atan2(y, x);
                return { lat: toDeg(œÜ2), lng: ((toDeg(Œª2) + 540) % 360) - 180 };
            };

            // Major Swiss lakes (rough centroids)
            const lakes = [
                { name: "Lake Geneva", lat: 46.45, lng: 6.6 },
                { name: "Lake Constance", lat: 47.6, lng: 9.4 },
                { name: "Lake Neuch√¢tel", lat: 46.9, lng: 6.85 },
                { name: "Lake Biel", lat: 47.1, lng: 7.2 },
                { name: "Lake Thun", lat: 46.73, lng: 7.65 },
                { name: "Lake Brienz", lat: 46.74, lng: 7.98 },
                { name: "Lake Lucerne", lat: 46.98, lng: 8.35 },
                { name: "Lake Zug", lat: 47.14, lng: 8.52 },
                { name: "Lake Zurich", lat: 47.27, lng: 8.7 },
                { name: "Lago Maggiore", lat: 46.15, lng: 8.65 },
                { name: "Lago di Lugano", lat: 46.0, lng: 8.95 },
            ];

            let nearestLake = { name: null, distanceM: Infinity };
            for (const lake of lakes) {
                const d = haversineMeters(lat, lng, lake.lat, lake.lng);
                if (d < nearestLake.distanceM) {
                    nearestLake = { name: lake.name, distanceM: d };
                }
            }

            // Build elevation sample points: center + ring
            const ring = [];
            for (let i = 0; i < ringPoints; i++) {
                ring.push(destinationPoint(lat, lng, (360 / ringPoints) * i, radiusMeters));
            }
            const samplePoints = [{ lat, lng }, ...ring];
            const lats = samplePoints.map((p) => p.lat.toFixed(6)).join(",");
            const lngs = samplePoints.map((p) => p.lng.toFixed(6)).join(",");

            let elevations = null;
            const demUrl = `https://api.open-meteo.com/v1/elevation?latitude=${lats}&longitude=${lngs}`;
            try {
                const ctrl = new AbortController();
                const timeout = setTimeout(() => ctrl.abort(), timeoutMs);
                const response = await fetch(demUrl, { signal: ctrl.signal });
                clearTimeout(timeout);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                if (!data || !Array.isArray(data.elevation)) throw new Error("Unexpected DEM response");
                elevations = data.elevation.filter((e) => Number.isFinite(e));
                if (elevations.length < samplePoints.length) throw new Error(`Missing elevations: got ${elevations.length}, need ${samplePoints.length}`);
            } catch (e) {
                console.warn("DEM fetch failed:", e.message);
                elevations = null;
            }

            // Scoring (0-100)
            let score = 0;
            const reasons = [];

            // Lake proximity (0-20 points)
            const lakeKm = nearestLake.distanceM / 1000;
            let lakePoints = 0;
            if (lakeKm <= 3) lakePoints = 20;
            else if (lakeKm <= 8) lakePoints = 14;
            else if (lakeKm <= 15) lakePoints = 8;
            else if (lakeKm <= 30) lakePoints = 3;
            score += lakePoints;
            if (lakePoints >= 8) {
                reasons.push(`Near ${nearestLake.name}`);
            }

            if (elevations) {
                const centerElev = elevations[0];
                const ringElevs = elevations.slice(1);
                const ringMean = ringElevs.reduce((a, b) => a + b, 0) / ringElevs.length;
                const bowlDepthM = ringMean - centerElev; // positive = lower than surroundings
                const reliefM = Math.max(...ringElevs) - Math.min(...ringElevs);

                // Elevation band (0-26 points) - lower elevations more fog-prone in Swiss Plateau
                let elevPoints = 0;
                if (centerElev < 600) elevPoints = 26;
                else if (centerElev < 900) elevPoints = 22;
                else if (centerElev < 1400) elevPoints = 14;
                else if (centerElev < 2000) elevPoints = 8;
                else elevPoints = 4;
                score += elevPoints;
                reasons.push(`${Math.round(centerElev)} m elevation`);

                // Bowl depth / cold-air pooling (‚àí6 to 34 points)
                let bowlPoints = 0;
                if (bowlDepthM >= 40) bowlPoints = 34;
                else if (bowlDepthM >= 25) bowlPoints = 28;
                else if (bowlDepthM >= 15) bowlPoints = 20;
                else if (bowlDepthM >= 8) bowlPoints = 12;
                else if (bowlDepthM >= 3) bowlPoints = 6;
                else if (bowlDepthM <= -10) bowlPoints = -6; // ridge/exposed
                score += bowlPoints;
                if (bowlPoints >= 20) {
                    reasons.push("valley/basin terrain");
                } else if (bowlPoints <= -4) {
                    reasons.push("exposed/ridge terrain");
                }

                // Relief / terrain complexity (0-20 points)
                let reliefPoints = 0;
                if (reliefM >= 300) reliefPoints = 20;
                else if (reliefM >= 180) reliefPoints = 14;
                else if (reliefM >= 100) reliefPoints = 9;
                else if (reliefM >= 60) reliefPoints = 5;
                score += reliefPoints;
            } else {
                // Fallback without elevation data
                score += 6;
                reasons.push("elevation data unavailable");
            }

            score = clamp(Math.round(score), 0, 100);

            let rating, ratingClass;
            if (score >= 75) {
                rating = "High";
                ratingClass = "rating-bad";
            } else if (score >= 55) {
                rating = "Moderate-High";
                ratingClass = "rating-bad";
            } else if (score >= 35) {
                rating = "Moderate";
                ratingClass = "rating-moderate";
            } else {
                rating = "Low";
                ratingClass = "rating-good";
            }

            return { rating, ratingClass, score, reasons };
        }

        async function updateFogProneness(origin) {
            const tbody = document.getElementById("nearby-body");
            const fogTd = tbody.querySelector('td[data-fog="value"]');
            if (!fogTd) return;

            fogTd.textContent = "Loading‚Ä¶";

            try {
                const result = await estimateFogProneness(origin.lat, origin.lng);
                const reasonText = result.reasons.length ? result.reasons.join(", ") : "‚Äî";

                fogTd.textContent = `${result.rating} `;
                fogTd.classList.remove("status");
                fogTd.classList.add(result.ratingClass);

                const infoIcon = document.createElement("span");
                infoIcon.className = "info-tooltip";
                infoIcon.setAttribute("role", "button");
                infoIcon.setAttribute("tabindex", "0");
                infoIcon.setAttribute("aria-label", "More info");
                infoIcon.textContent = "\u24D8";

                const tooltipText = document.createElement("span");
                tooltipText.className = "tooltip-text";
                tooltipText.textContent = `Fog estimate: ${reasonText}`;
                infoIcon.appendChild(tooltipText);

                infoIcon.addEventListener("click", (e) => {
                    e.stopPropagation();
                    infoIcon.classList.toggle("active");
                });

                fogTd.appendChild(infoIcon);
            } catch (err) {
                console.warn("Fog estimate failed:", err.message);
                fogTd.textContent = "Unavailable";
            }
        }

        // --- Nearby forest coverage ---
        function closeRing(coords) {
            if (coords.length >= 3 &&
                (coords[0][0] !== coords[coords.length - 1][0] ||
                 coords[0][1] !== coords[coords.length - 1][1])) {
                coords.push(coords[0]);
            }
            return coords;
        }

        async function updateNearbyForest(origin) {
            const tbody = document.getElementById("nearby-body");
            const combinedTd = tbody.querySelector('td[data-forest="combined"]');
            if (!combinedTd) return;

            combinedTd.textContent = "Loading‚Ä¶";

            if (typeof turf === "undefined") {
                combinedTd.textContent = "Turf.js unavailable";
                return;
            }

            const overpassQuery = `[out:json];(way["landuse"="forest"](around:3000,${origin.lat},${origin.lng});relation["landuse"="forest"](around:3000,${origin.lat},${origin.lng});way["natural"="wood"](around:3000,${origin.lat},${origin.lng});relation["natural"="wood"](around:3000,${origin.lat},${origin.lng}););out geom;`;

            try {
                const response = await fetch("https://overpass-api.de/api/interpreter", {
                    method: "POST",
                    body: new URLSearchParams({ data: overpassQuery }),
                    headers: { "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8" },
                });
                if (!response.ok) throw new Error("Overpass query failed");
                const data = await response.json();
                const elements = data.elements || [];

                const features = [];
                elements.forEach((el) => {
                    if (el.geometry && el.geometry.length) {
                        const coords = el.geometry.map((p) => [p.lon, p.lat]);
                        if (coords.length >= 3) {
                            closeRing(coords);
                            try {
                                features.push(turf.polygon([coords], { id: el.id, osmType: el.type }));
                            } catch (e) {
                                console.warn(`Invalid polygon geometry for element ${el.id}:`, e.message);
                            }
                        } else if (coords.length) {
                            try {
                                features.push(turf.lineString(coords, { id: el.id, osmType: el.type }));
                            } catch (e) {
                                console.warn(`Invalid lineString geometry for element ${el.id}:`, e.message);
                            }
                        }
                    } else if (el.type === "relation" && el.members) {
                        const rings = [];
                        el.members.forEach((m) => {
                            if (m.geometry && m.geometry.length) {
                                const c = m.geometry.map((p) => [p.lon, p.lat]);
                                if (c.length >= 3) {
                                    closeRing(c);
                                    rings.push(c);
                                }
                            }
                        });
                        if (rings.length) {
                            try {
                                features.push(turf.polygon(rings, { id: el.id, osmType: el.type }));
                            } catch (e) {
                                console.warn(`Invalid relation polygon for element ${el.id}:`, e.message);
                            }
                        }
                    }
                });

                const circle = turf.circle([origin.lng, origin.lat], 3000, { steps: 64, units: "meters" });
                const circleArea = turf.area(circle);

                let totalArea = 0;
                features.forEach((f) => {
                    try {
                        const inter = turf.intersect(f, circle);
                        if (inter) totalArea += turf.area(inter);
                    } catch (e) {
                        console.warn("Intersection calculation failed:", e.message);
                    }
                });

                const percent = circleArea > 0 ? (totalArea / circleArea) * 100 : 0;

                let forestRating, forestRatingClass;
                if (percent >= 20) {
                    forestRating = "High";
                    forestRatingClass = "rating-good";
                } else if (percent >= 10) {
                    forestRating = "Moderate";
                    forestRatingClass = "rating-moderate";
                } else {
                    forestRating = "Low";
                    forestRatingClass = "rating-bad";
                }

                combinedTd.textContent = `${forestRating} `;
                combinedTd.classList.remove("status");
                combinedTd.classList.add(forestRatingClass);
                combinedTd.removeAttribute("data-loading");

                const infoIcon = document.createElement("span");
                infoIcon.className = "info-tooltip";
                infoIcon.setAttribute("role", "button");
                infoIcon.setAttribute("tabindex", "0");
                infoIcon.setAttribute("aria-label", "More info");
                infoIcon.textContent = "\u24D8";

                const tooltipText = document.createElement("span");
                tooltipText.className = "tooltip-text";
                tooltipText.textContent = `${percent.toFixed(1)}% forest within 3 km`;
                infoIcon.appendChild(tooltipText);

                infoIcon.addEventListener("click", (e) => {
                    e.stopPropagation();
                    infoIcon.classList.toggle("active");
                });

                combinedTd.appendChild(infoIcon);
            } catch (err) {
                combinedTd.textContent = "Unable to load forest data.";
            }
        }

        async function handleSearch() {
            const query = normalizeQuery(addressInput.value);
            if (!query) {
                searchStatus.textContent = "";
                return;
            }
            searchStatus.textContent = "Searching‚Ä¶";
            searchButton.disabled = true;

            try {
                const result = await geocode(query);
                const origin = { lat: result.lat, lng: result.lng };
                // Prefer embedding by coordinates to show the location pin only
                mapFrame.src = buildGoogleMapEmbed(result.label, result.lat, result.lng);
                shadeLink.href = buildShadeMapLink(result.lat, result.lng);
                if (typeof schweizLink !== "undefined" && schweizLink) {
                    schweizLink.href = buildSchweizmobilLink(result.lat, result.lng);
                }
                searchStatus.textContent = query;
                await updateTravelTimes(origin);
                await updateNearbyGyms(origin);
                await updateNearbyForest(origin);
                await updateFogProneness(origin);
            } catch (error) {
                searchStatus.textContent = "No results found. Try a more specific address.";
            } finally {
                searchButton.disabled = false;
            }
        }

        searchButton.addEventListener("click", () => {
            handleSearch();
        });

        addressInput.addEventListener("keydown", (event) => {
            if (event.key === "Enter") {
                handleSearch();
            }
        });

        renderTravelTable();

        // Close tooltips when clicking elsewhere
        document.addEventListener("click", () => {
            document.querySelectorAll(".info-tooltip.active").forEach((el) => {
                el.classList.remove("active");
            });
        });

        // Load default address on page load
        addressInput.value = "Freilagerstrasse 99, 8047 Z√ºrich";
        handleSearch();
    </script>
</body>

</html>